## 数据存储方式
- 一般而言基本数据类型用栈存储，引用类型用堆
### 基本数据类型
- undefined
- null
- number
- bigInt
- boolean
- symbol
- string
- Object（引用类型）

#### 赋值
- 原始类型的数据直接完整的赋值变量值，引用类型是赋值引用地址

```js
let a = {x:1}
let b = a
b.x = 7
console.log(a) //{x:7} // a 与 b 指向的同一个内存地址 所以b的改变影响了a
```

- 对于系统栈来说，除了保存变量之外，还有创建并切换执行上下文的功能
- 采用栈存放复杂对象类型，切换上下文的开销会变大
- 堆内存空间虽大，但是垃圾回收时开销较大

## v8引擎怎么进行垃圾内存的回收
### v8内存限制
- v8只能使用系统的一部分内存
    - 64位下 最多分配1.4G
    - 32位下 最多分配0.7G
- 限制内存的原因
    - js 单线程执行机制
    - js 垃圾回收机制的限制
    ```text
       以1.5G大小为例，v8做一次小的垃圾回收需要50ms，做一次非增量式的垃圾回收甚至要1s以上
    ```
    - 可通过命令配置内存大小（新生代、老生代）
### 新生代内存回收
- v8 把堆内存分成两部分，新生代与老生代
    - 新生代：临时分配的内存，存活时间短（64位：32M  32位：16M）
    - 老生代：常驻内存，存活时间长
- 新生代空间分为平均的两部分 Form 与 To
- 垃圾回收时，V8将Form部分的对象检查一遍，如果是存活的则复制到To内存中，非存活则直接回收
- Form中存活对象进入To后Form与To对调 Form被闲置（所以新生代只有一半的内存会被使用不会超过）
- To内存中对象按照顺序从头放置，会造成内存不连续，堆内存是连续分配的，零散的空间会造成大一点的对象没办法进行空间分配，这种零散空间叫空间碎片
- 通过Scavenge算法解决碎片问题（缺点：只能使用新生代内存一半，优点：时间性能优秀，因为此类对象少）

### 老生代内存回收
- 新生代的变量经过多次回收后依然存在，就会被放到老生代中（晋升）
- 老生代回收策略
    - 进行标记-清除，遍历堆中的所有对象，打上标记，对使用的变量及被强引用的变量取消标记，随后清除其他标记对象
    - 整理内存碎片，将存活的对象全部往一端靠拢（由于是移动对象所以耗时较长）
    
### 增量标记
- 由于是单线程，v8在垃圾回收时，不可避免的会阻塞业务代码执行，若老生代回收任务重，会严重影响应用性能。
- v8采用增量标记的方式，将一口气标记的任务分成很多小任务，每完成一个就歇一会 执行js逻辑， 然后再执行下面的部分
    
    
## v8执行一段代码的过程
- 机器读不懂js代码，机器只能理解特定的机器码，js属于解释型语言，解释器会对源代码做以下分析
    - 通过词法分析与语法分析生成AST（抽象树语法）
    - 生成字节码

### 生成AST
- 生成AST分为两部分-- 词法分析语法分析
#### 词法分析
- 词法分析即分词，他的工作就是将一行行代码分解成一个个token如

```js
let name = 'zhangsan'
```

- 解释器会将其分为四个部分 关键字（let）变量名（name） 赋值（=） 字符串（zhangsan）
- babel的工作原理就是将es6的代码解析成ES5的AST，然后将ES5的AST转成ES6的AST
- 生成AST后，生成执行上下文

### 生成字节码
- 生成AST后通过v8的解释器生成字节码（本来是直接生成机器码，但是后来机器码体积太大，引发严重内存占用问题）
- 字节码是介于AST与机器码之间的一种代码，
